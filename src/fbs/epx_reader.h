#ifndef EPX_READER_H
#define EPX_READER_H

/* Generated by flatcc 0.5.3-pre FlatBuffers schema compiler for C by dvide.com */

#ifndef FLATBUFFERS_COMMON_READER_H
#include "flatbuffers_common_reader.h"
#endif
#include "flatcc/flatcc_flatbuffers.h"
#ifndef __alignas_is_defined
#include <stdalign.h>
#endif
#include "flatcc/flatcc_prologue.h"
#ifndef flatbuffers_identifier
#define flatbuffers_identifier 0
#endif
#ifndef flatbuffers_extension
#define flatbuffers_extension ".bin"
#endif

typedef struct epx_instance_id epx_instance_id_t;
typedef const epx_instance_id_t *epx_instance_id_struct_t;
typedef epx_instance_id_t *epx_instance_id_mutable_struct_t;
typedef const epx_instance_id_t *epx_instance_id_vec_t;
typedef epx_instance_id_t *epx_instance_id_mutable_vec_t;
typedef struct epx_dependency epx_dependency_t;
typedef const epx_dependency_t *epx_dependency_struct_t;
typedef epx_dependency_t *epx_dependency_mutable_struct_t;
typedef const epx_dependency_t *epx_dependency_vec_t;
typedef epx_dependency_t *epx_dependency_mutable_vec_t;

typedef const struct epx_command_table *epx_command_table_t;
typedef const flatbuffers_uoffset_t *epx_command_vec_t;
typedef flatbuffers_uoffset_t *epx_command_mutable_vec_t;
typedef const struct epx_instance_data_table *epx_instance_data_table_t;
typedef const flatbuffers_uoffset_t *epx_instance_data_vec_t;
typedef flatbuffers_uoffset_t *epx_instance_data_mutable_vec_t;
typedef const struct epx_message_table *epx_message_table_t;
typedef const flatbuffers_uoffset_t *epx_message_vec_t;
typedef flatbuffers_uoffset_t *epx_message_mutable_vec_t;
typedef const struct epx_batch_table *epx_batch_table_t;
typedef const flatbuffers_uoffset_t *epx_batch_vec_t;
typedef flatbuffers_uoffset_t *epx_batch_mutable_vec_t;
typedef const struct epx_instance_table *epx_instance_table_t;
typedef const flatbuffers_uoffset_t *epx_instance_vec_t;
typedef flatbuffers_uoffset_t *epx_instance_mutable_vec_t;
#ifndef epx_command_identifier
#define epx_command_identifier flatbuffers_identifier
#endif
#define epx_command_type_hash ((flatbuffers_thash_t)0x1b6d3483)
#define epx_command_type_identifier "\x83\x34\x6d\x1b"
#ifndef epx_instance_id_identifier
#define epx_instance_id_identifier flatbuffers_identifier
#endif
#define epx_instance_id_type_hash ((flatbuffers_thash_t)0xf802c71b)
#define epx_instance_id_type_identifier "\x1b\xc7\x02\xf8"
#ifndef epx_dependency_identifier
#define epx_dependency_identifier flatbuffers_identifier
#endif
#define epx_dependency_type_hash ((flatbuffers_thash_t)0x61dca7b7)
#define epx_dependency_type_identifier "\xb7\xa7\xdc\x61"
#ifndef epx_instance_data_identifier
#define epx_instance_data_identifier flatbuffers_identifier
#endif
#define epx_instance_data_type_hash ((flatbuffers_thash_t)0x7101a386)
#define epx_instance_data_type_identifier "\x86\xa3\x01\x71"
#ifndef epx_message_identifier
#define epx_message_identifier flatbuffers_identifier
#endif
#define epx_message_type_hash ((flatbuffers_thash_t)0xbbdfeae9)
#define epx_message_type_identifier "\xe9\xea\xdf\xbb"
#ifndef epx_batch_identifier
#define epx_batch_identifier flatbuffers_identifier
#endif
#define epx_batch_type_hash ((flatbuffers_thash_t)0xd469972e)
#define epx_batch_type_identifier "\x2e\x97\x69\xd4"
#ifndef epx_instance_identifier
#define epx_instance_identifier flatbuffers_identifier
#endif
#define epx_instance_type_hash ((flatbuffers_thash_t)0x4a5c027d)
#define epx_instance_type_identifier "\x7d\x02\x5c\x4a"

typedef uint8_t epx_io_t_enum_t;
__flatbuffers_define_integer_type(epx_io_t, epx_io_t_enum_t, 8)
#define epx_io_t_READ ((epx_io_t_enum_t)UINT8_C(0))
#define epx_io_t_WRITE ((epx_io_t_enum_t)UINT8_C(1))

static inline const char *epx_io_t_name(epx_io_t_enum_t value)
{
    switch (value) {
    case epx_io_t_READ: return "READ";
    case epx_io_t_WRITE: return "WRITE";
    default: return "";
    }
}

static inline int epx_io_t_is_known_value(epx_io_t_enum_t value)
{
    switch (value) {
    case epx_io_t_READ: return 1;
    case epx_io_t_WRITE: return 1;
    default: return 0;
    }
}

typedef uint8_t epx_message_t_enum_t;
__flatbuffers_define_integer_type(epx_message_t, epx_message_t_enum_t, 8)
#define epx_message_t_NACK ((epx_message_t_enum_t)UINT8_C(0))
#define epx_message_t_PHASE1 ((epx_message_t_enum_t)UINT8_C(1))
#define epx_message_t_PRE_ACCEPT ((epx_message_t_enum_t)UINT8_C(2))
#define epx_message_t_PRE_ACCEPT_OK ((epx_message_t_enum_t)UINT8_C(3))
#define epx_message_t_PRE_ACCEPT_REPLY ((epx_message_t_enum_t)UINT8_C(4))
#define epx_message_t_ACCEPT ((epx_message_t_enum_t)UINT8_C(5))
#define epx_message_t_ACCEPT_REPLY ((epx_message_t_enum_t)UINT8_C(6))
#define epx_message_t_ACCEPT_OK ((epx_message_t_enum_t)UINT8_C(7))
#define epx_message_t_COMMIT ((epx_message_t_enum_t)UINT8_C(8))
#define epx_message_t_PREPARE ((epx_message_t_enum_t)UINT8_C(9))
#define epx_message_t_PREPARE_REPLY ((epx_message_t_enum_t)UINT8_C(10))
#define epx_message_t_PREPARE_OK ((epx_message_t_enum_t)UINT8_C(11))

static inline const char *epx_message_t_name(epx_message_t_enum_t value)
{
    switch (value) {
    case epx_message_t_NACK: return "NACK";
    case epx_message_t_PHASE1: return "PHASE1";
    case epx_message_t_PRE_ACCEPT: return "PRE_ACCEPT";
    case epx_message_t_PRE_ACCEPT_OK: return "PRE_ACCEPT_OK";
    case epx_message_t_PRE_ACCEPT_REPLY: return "PRE_ACCEPT_REPLY";
    case epx_message_t_ACCEPT: return "ACCEPT";
    case epx_message_t_ACCEPT_REPLY: return "ACCEPT_REPLY";
    case epx_message_t_ACCEPT_OK: return "ACCEPT_OK";
    case epx_message_t_COMMIT: return "COMMIT";
    case epx_message_t_PREPARE: return "PREPARE";
    case epx_message_t_PREPARE_REPLY: return "PREPARE_REPLY";
    case epx_message_t_PREPARE_OK: return "PREPARE_OK";
    default: return "";
    }
}

static inline int epx_message_t_is_known_value(epx_message_t_enum_t value)
{
    switch (value) {
    case epx_message_t_NACK: return 1;
    case epx_message_t_PHASE1: return 1;
    case epx_message_t_PRE_ACCEPT: return 1;
    case epx_message_t_PRE_ACCEPT_OK: return 1;
    case epx_message_t_PRE_ACCEPT_REPLY: return 1;
    case epx_message_t_ACCEPT: return 1;
    case epx_message_t_ACCEPT_REPLY: return 1;
    case epx_message_t_ACCEPT_OK: return 1;
    case epx_message_t_COMMIT: return 1;
    case epx_message_t_PREPARE: return 1;
    case epx_message_t_PREPARE_REPLY: return 1;
    case epx_message_t_PREPARE_OK: return 1;
    default: return 0;
    }
}

typedef uint8_t epx_status_enum_t;
__flatbuffers_define_integer_type(epx_status, epx_status_enum_t, 8)
#define epx_status_NONE ((epx_status_enum_t)UINT8_C(1))
#define epx_status_PRE_ACCEPTED ((epx_status_enum_t)UINT8_C(2))
#define epx_status_ACCEPTED ((epx_status_enum_t)UINT8_C(4))
#define epx_status_PREPARE ((epx_status_enum_t)UINT8_C(8))
#define epx_status_COMMITTED ((epx_status_enum_t)UINT8_C(16))
#define epx_status_EXECUTED ((epx_status_enum_t)UINT8_C(32))

static inline const char *epx_status_name(epx_status_enum_t value)
{
    switch (value) {
    case epx_status_NONE: return "NONE";
    case epx_status_PRE_ACCEPTED: return "PRE_ACCEPTED";
    case epx_status_ACCEPTED: return "ACCEPTED";
    case epx_status_PREPARE: return "PREPARE";
    case epx_status_COMMITTED: return "COMMITTED";
    case epx_status_EXECUTED: return "EXECUTED";
    default: return "";
    }
}

static inline int epx_status_is_known_value(epx_status_enum_t value)
{
    switch (value) {
    case epx_status_NONE: return 1;
    case epx_status_PRE_ACCEPTED: return 1;
    case epx_status_ACCEPTED: return 1;
    case epx_status_PREPARE: return 1;
    case epx_status_COMMITTED: return 1;
    case epx_status_EXECUTED: return 1;
    default: return 0;
    }
}


struct epx_instance_id {
    alignas(8) uint16_t replica_id;
    alignas(8) uint64_t instance_id;
};
static_assert(sizeof(epx_instance_id_t) == 16, "struct size mismatch");

static inline const epx_instance_id_t *epx_instance_id__const_ptr_add(const epx_instance_id_t *p, size_t i) { return p + i; }
static inline epx_instance_id_t *epx_instance_id__ptr_add(epx_instance_id_t *p, size_t i) { return p + i; }
static inline epx_instance_id_struct_t epx_instance_id_vec_at(epx_instance_id_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t epx_instance_id__size() { return 16; }
static inline size_t epx_instance_id_vec_len(epx_instance_id_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(epx_instance_id)

__flatbuffers_define_struct_scalar_field(epx_instance_id, replica_id, flatbuffers_uint16, uint16_t)
__flatbuffers_define_struct_scalar_field(epx_instance_id, instance_id, flatbuffers_uint64, uint64_t)
/* Note: field has key, but there is no support for find by fields of this type. */

struct epx_dependency {
    alignas(8) uint16_t replica_id;
    alignas(8) uint64_t instance_id;
    alignas(1) uint8_t committed;
};
static_assert(sizeof(epx_dependency_t) == 24, "struct size mismatch");

static inline const epx_dependency_t *epx_dependency__const_ptr_add(const epx_dependency_t *p, size_t i) { return p + i; }
static inline epx_dependency_t *epx_dependency__ptr_add(epx_dependency_t *p, size_t i) { return p + i; }
static inline epx_dependency_struct_t epx_dependency_vec_at(epx_dependency_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t epx_dependency__size() { return 24; }
static inline size_t epx_dependency_vec_len(epx_dependency_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(epx_dependency)

__flatbuffers_define_struct_scalar_field(epx_dependency, replica_id, flatbuffers_uint16, uint16_t)
__flatbuffers_define_struct_scalar_field(epx_dependency, instance_id, flatbuffers_uint64, uint64_t)
__flatbuffers_define_struct_scalar_field(epx_dependency, committed, flatbuffers_uint8, uint8_t)


struct epx_command_table { uint8_t unused__; };

static inline size_t epx_command_vec_len(epx_command_vec_t vec)
__flatbuffers_vec_len(vec)
static inline epx_command_table_t epx_command_vec_at(epx_command_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(epx_command_table_t, vec, i, 0)
__flatbuffers_table_as_root(epx_command)

__flatbuffers_define_scalar_field(0, epx_command, id, flatbuffers_uint8, uint8_t, UINT8_C(0))
__flatbuffers_define_string_field(1, epx_command, start_key, 0)
__flatbuffers_define_string_field(2, epx_command, end_key, 0)
__flatbuffers_define_scalar_field(3, epx_command, writing, epx_io_t, epx_io_t_enum_t, UINT8_C(0))
__flatbuffers_define_vector_field(4, epx_command, value, flatbuffers_uint8_vec_t, 0)

struct epx_instance_data_table { uint8_t unused__; };

static inline size_t epx_instance_data_vec_len(epx_instance_data_vec_t vec)
__flatbuffers_vec_len(vec)
static inline epx_instance_data_table_t epx_instance_data_vec_at(epx_instance_data_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(epx_instance_data_table_t, vec, i, 0)
__flatbuffers_table_as_root(epx_instance_data)

__flatbuffers_define_table_field(0, epx_instance_data, command, epx_command_table_t, 0)
__flatbuffers_define_scalar_field(1, epx_instance_data, seq, flatbuffers_uint64, uint64_t, UINT64_C(0))
__flatbuffers_define_vector_field(2, epx_instance_data, deps, epx_dependency_vec_t, 0)

struct epx_message_table { uint8_t unused__; };

static inline size_t epx_message_vec_len(epx_message_vec_t vec)
__flatbuffers_vec_len(vec)
static inline epx_message_table_t epx_message_vec_at(epx_message_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(epx_message_table_t, vec, i, 0)
__flatbuffers_table_as_root(epx_message)

__flatbuffers_define_scalar_field(0, epx_message, to, flatbuffers_uint16, uint16_t, UINT16_C(0))
__flatbuffers_define_scalar_field(1, epx_message, ballot, flatbuffers_uint8, uint8_t, UINT8_C(0))
__flatbuffers_define_struct_field(2, epx_message, instance_id, epx_instance_id_struct_t, 0)
__flatbuffers_define_scalar_field(3, epx_message, type, epx_message_t, epx_message_t_enum_t, UINT8_C(0))
__flatbuffers_define_table_field(4, epx_message, data, epx_instance_data_table_t, 0)
__flatbuffers_define_scalar_field(5, epx_message, reply_from, flatbuffers_uint16, uint16_t, UINT16_C(0))

struct epx_batch_table { uint8_t unused__; };

static inline size_t epx_batch_vec_len(epx_batch_vec_t vec)
__flatbuffers_vec_len(vec)
static inline epx_batch_table_t epx_batch_vec_at(epx_batch_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(epx_batch_table_t, vec, i, 0)
__flatbuffers_table_as_root(epx_batch)

__flatbuffers_define_scalar_field(0, epx_batch, id, flatbuffers_uint64, uint64_t, UINT64_C(0))
__flatbuffers_define_vector_field(1, epx_batch, messages, epx_message_vec_t, 0)

struct epx_instance_table { uint8_t unused__; };

static inline size_t epx_instance_vec_len(epx_instance_vec_t vec)
__flatbuffers_vec_len(vec)
static inline epx_instance_table_t epx_instance_vec_at(epx_instance_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(epx_instance_table_t, vec, i, 0)
__flatbuffers_table_as_root(epx_instance)

__flatbuffers_define_struct_field(0, epx_instance, key, epx_instance_id_struct_t, 0)
__flatbuffers_define_scalar_field(1, epx_instance, ballot, flatbuffers_uint8, uint8_t, UINT8_C(0))
__flatbuffers_define_scalar_field(2, epx_instance, status, epx_status, epx_status_enum_t, UINT8_C(1))
__flatbuffers_define_table_field(3, epx_instance, idata, epx_instance_data_table_t, 0)

#include "flatcc/flatcc_epilogue.h"
#endif /* EPX_READER_H */
